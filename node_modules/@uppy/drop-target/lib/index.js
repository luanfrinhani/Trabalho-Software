var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('@uppy/core'),
    Plugin = _require.Plugin;

var getDroppedFiles = require('@uppy/utils/lib/getDroppedFiles');

var toArray = require('@uppy/utils/lib/toArray');
/**
 * Drop Target plugin
 *
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(DropTarget, _Plugin);

  function DropTarget(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.addFiles = function (files) {
      var descriptors = files.map(function (file) {
        return {
          source: _this.id,
          name: file.name,
          type: file.type,
          data: file,
          meta: {
            // path of the file relative to the ancestor directory the user selected.
            // e.g. 'docs/Old Prague/airbnb.pdf'
            relativePath: file.relativePath || null
          }
        };
      });

      try {
        _this.uppy.addFiles(descriptors);
      } catch (err) {
        _this.uppy.log(err);
      }
    };

    _this.handleDrop = function (event) {
      event.preventDefault();
      event.stopPropagation();
      clearTimeout(_this.removeDragOverClassTimeout); // 2. Remove dragover class

      event.currentTarget.classList.remove('uppy-is-drag-over');

      _this.setPluginState({
        isDraggingOver: false
      }); // 3. Add all dropped files


      _this.uppy.log('[DropTarget] Files were dropped');

      var logDropError = function logDropError(error) {
        _this.uppy.log(error, 'error');
      };

      getDroppedFiles(event.dataTransfer, {
        logDropError: logDropError
      }).then(function (files) {
        return _this.addFiles(files);
      });
    };

    _this.handleDragOver = function (event) {
      event.preventDefault();
      event.stopPropagation(); // 1. Add a small (+) icon on drop
      // (and prevent browsers from interpreting this as files being _moved_ into the browser,
      // https://github.com/transloadit/uppy/issues/1978)

      event.dataTransfer.dropEffect = 'copy';
      clearTimeout(_this.removeDragOverClassTimeout);
      event.currentTarget.classList.add('uppy-is-drag-over');

      _this.setPluginState({
        isDraggingOver: true
      });
    };

    _this.handleDragLeave = function (event) {
      event.preventDefault();
      event.stopPropagation();
      var currentTarget = event.currentTarget;
      clearTimeout(_this.removeDragOverClassTimeout); // Timeout against flickering, this solution is taken from drag-drop library.
      // Solution with 'pointer-events: none' didn't work across browsers.

      _this.removeDragOverClassTimeout = setTimeout(function () {
        currentTarget.classList.remove('uppy-is-drag-over');

        _this.setPluginState({
          isDraggingOver: false
        });
      }, 50);
    };

    _this.addListeners = function () {
      var target = _this.opts.target;

      if (target instanceof Element) {
        _this.nodes = [target];
      } else if (typeof target === 'string') {
        _this.nodes = toArray(document.querySelectorAll(target));
      }

      if (!_this.nodes && !_this.nodes.length > 0) {
        throw new Error("\"" + target + "\" does not match any HTML elements");
      }

      _this.nodes.forEach(function (node) {
        node.addEventListener('dragover', _this.handleDragOver, false);
        node.addEventListener('dragleave', _this.handleDragLeave, false);
        node.addEventListener('drop', _this.handleDrop, false);
      });
    };

    _this.removeListeners = function () {
      if (_this.nodes) {
        _this.nodes.forEach(function (node) {
          node.removeEventListener('dragover', _this.handleDragOver, false);
          node.removeEventListener('dragleave', _this.handleDragLeave, false);
          node.removeEventListener('drop', _this.handleDrop, false);
        });
      }
    };

    _this.type = 'acquirer';
    _this.id = _this.opts.id || 'DropTarget';
    _this.title = 'Drop Target'; // Default options

    var defaultOpts = {
      target: null
    }; // Merge default options with the ones set by user

    _this.opts = _extends({}, defaultOpts, opts);
    _this.removeDragOverClassTimeout = null;
    return _this;
  }

  var _proto = DropTarget.prototype;

  _proto.install = function install() {
    this.setPluginState({
      isDraggingOver: false
    });
    this.addListeners();
  };

  _proto.uninstall = function uninstall() {
    this.removeListeners();
  };

  return DropTarget;
}(Plugin), _class.VERSION = "0.2.1", _temp);